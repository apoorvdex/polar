"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PagemarkRect_1 = require("./PagemarkRect");
const Pagemark_1 = require("./Pagemark");
const Logger_1 = require("../logger/Logger");
const Hashcodes_1 = require("../Hashcodes");
const Objects_1 = require("../util/Objects");
const PagemarkType_1 = require("./PagemarkType");
const PagemarkRects_1 = require("./PagemarkRects");
const Dictionaries_1 = require("../util/Dictionaries");
const Percentages_1 = require("../util/Percentages");
const PagemarkMode_1 = require("./PagemarkMode");
const DocMetas_1 = require("./DocMetas");
const Preconditions_1 = require("../Preconditions");
const ISODateTimeStrings_1 = require("./ISODateTimeStrings");
const Numbers_1 = require("../util/Numbers");
const Reducers_1 = require("../util/Reducers");
const ReadingProgresses_1 = require("./ReadingProgresses");
const HitMap_1 = require("../util/HitMap");
const ReadingOverviews_1 = require("./ReadingOverviews");
const log = Logger_1.Logger.create();
const DEFAULT_PAGEMARK_RECT = new PagemarkRect_1.PagemarkRect({
    left: 0,
    top: 0,
    width: 100,
    height: 100
});
class Pagemarks {
    static createID(created) {
        return Hashcodes_1.Hashcodes.createID({ created, sequence: this.sequences.id++ });
    }
    static updatePagemarksForRange(docMeta, end, percentage = 100) {
        if (end < 1) {
            throw new Error("Page number must be 1 or more");
        }
        const created = ISODateTimeStrings_1.ISODateTimeStrings.create();
        const batch = Hashcodes_1.Hashcodes.createID({ created, id: this.sequences.batch++ });
        const calculateStartPage = () => {
            const range = [...Numbers_1.Numbers.range(1, Math.max(1, end - 1))].reverse();
            for (const r of range) {
                const pageMeta = DocMetas_1.DocMetas.getPageMeta(docMeta, r);
                if (Dictionaries_1.Dictionaries.size(pageMeta.pagemarks || {}) !== 0) {
                    return r;
                }
            }
            return 1;
        };
        const createPagemarkRect = (pageNum, percentage = 100) => {
            const pageMeta = DocMetas_1.DocMetas.getPageMeta(docMeta, pageNum);
            const pagemarks = Object.values(pageMeta.pagemarks || {});
            if (pagemarks.length === 0) {
                return PagemarkRects_1.PagemarkRects.createFromRect({
                    left: 0,
                    top: 0,
                    height: percentage,
                    width: 100
                });
            }
            let top = 0;
            for (const pagemark of pagemarks) {
                const newTop = pagemark.rect.top + pagemark.rect.height;
                if (newTop > top) {
                    top = newTop;
                }
            }
            if (pagemarks.map(pagemark => pagemark.percentage)
                .reduce(Reducers_1.Reducers.SUM, 0) === 100) {
                return undefined;
            }
            return PagemarkRects_1.PagemarkRects.createFromRect({
                left: 0,
                top,
                height: 100 - top,
                width: 100
            });
        };
        const start = calculateStartPage();
        const result = [];
        DocMetas_1.DocMetas.withBatchedMutations(docMeta, () => {
            for (const pageNum of Numbers_1.Numbers.range(start, end)) {
                const rectPercentage = pageNum === end ? percentage : 100;
                const rect = createPagemarkRect(pageNum, rectPercentage);
                if (rect) {
                    const pagemark = Pagemarks.create({ created, rect, batch });
                    Pagemarks.updatePagemark(docMeta, pageNum, pagemark);
                    result.push({ pageNum, pagemark });
                }
            }
        });
        return result;
    }
    static create(opts = {}) {
        const options = Objects_1.Objects.defaults(opts, {
            type: PagemarkType_1.PagemarkType.SINGLE_COLUMN,
            column: 0,
        });
        const keyOptions = Pagemarks.createKeyOptions(options);
        if (keyOptions.count === 0) {
            throw new Error("Must specify either rect or percentage.");
        }
        if (keyOptions.count === 1) {
            if (keyOptions.hasPercentage) {
                keyOptions.rect = PagemarkRects_1.PagemarkRects.createFromPercentage(keyOptions.percentage);
            }
            if (keyOptions.hasRect) {
                keyOptions.percentage = keyOptions.rect.toPercentage();
            }
        }
        if (Percentages_1.round(keyOptions.percentage) !== Percentages_1.round(keyOptions.rect.toPercentage())) {
            const msg = "Percentage and rect are not the same";
            log.warn(msg, keyOptions.percentage, keyOptions.rect, keyOptions.rect.toPercentage());
            throw new Error(msg);
        }
        const created = options.created || ISODateTimeStrings_1.ISODateTimeStrings.create();
        const batch = options.batch || Hashcodes_1.Hashcodes.createID({ created, id: this.sequences.batch++ });
        const mode = options.mode || PagemarkMode_1.PagemarkMode.READ;
        return new Pagemark_1.Pagemark({
            id: Pagemarks.createID(created),
            created,
            type: options.type,
            percentage: keyOptions.percentage,
            column: options.column,
            rect: keyOptions.rect,
            batch,
            mode
        });
    }
    static createKeyOptions(options) {
        const keyOptions = {
            count: 0,
            hasPercentage: false,
            hasRect: false,
            rect: options.rect,
            percentage: options.percentage
        };
        keyOptions.hasPercentage = "percentage" in options;
        keyOptions.hasRect = "rect" in options;
        if (keyOptions.hasPercentage) {
            ++keyOptions.count;
        }
        if (keyOptions.hasRect) {
            ++keyOptions.count;
        }
        return keyOptions;
    }
    static upgrade(pagemarks) {
        const result = {};
        Object.assign(result, pagemarks);
        Dictionaries_1.Dictionaries.forDict(result, (key, pagemark) => {
            if (!pagemark.rect) {
                if (pagemark.percentage >= 0 && pagemark.percentage <= 100) {
                    pagemark.rect = PagemarkRects_1.PagemarkRects.createFromPercentage(pagemark.percentage);
                }
            }
            if (!pagemark.id) {
                pagemark.id = key;
            }
            if (!pagemark.mode) {
                pagemark.mode = PagemarkMode_1.PagemarkMode.READ;
            }
            if (!Preconditions_1.isPresent(pagemark.percentage)) {
                pagemark.percentage = 0;
            }
        });
        return result;
    }
    static updatePagemark(docMeta, pageNum, pagemark) {
        this.doDocMetaMutation(docMeta, pageNum, () => {
            const pageMeta = DocMetas_1.DocMetas.getPageMeta(docMeta, pageNum);
            this.doPageMetaMutation(pageMeta, () => {
                pageMeta.pagemarks[pagemark.id] = pagemark;
            });
        });
    }
    static replacePagemark(docMeta, pagemarkPtr, options) {
        const pagemarksToMutate = () => {
            const result = [];
            if (pagemarkPtr.ref) {
                const pageMeta = DocMetas_1.DocMetas.getPageMeta(docMeta, pagemarkPtr.ref.pageNum);
                result.push({ pageMeta, id: pagemarkPtr.ref.pagemark.id });
            }
            if (pagemarkPtr.batch) {
                result.push(...this.pagemarksWithinBatch(docMeta, pagemarkPtr.batch));
            }
            return result;
        };
        const pagemarkRefs = pagemarksToMutate();
        DocMetas_1.DocMetas.withBatchedMutations(docMeta, () => {
            for (const ref of pagemarkRefs) {
                const currPagemark = ref.pageMeta.pagemarks[ref.id];
                const newPagemark = new Pagemark_1.Pagemark(currPagemark);
                if (options.mode) {
                    newPagemark.mode = options.mode;
                }
                this.doPageMetaMutation(ref.pageMeta, () => {
                    ref.pageMeta.pagemarks[ref.id] = newPagemark;
                });
            }
        });
    }
    static deletePagemark(docMeta, pageNum, id) {
        this.doDocMetaMutation(docMeta, pageNum, () => {
            const pageMeta = DocMetas_1.DocMetas.getPageMeta(docMeta, pageNum);
            let pageMetaMutator;
            if (id) {
                const primaryPagemark = pageMeta.pagemarks[id];
                if (primaryPagemark) {
                    if (primaryPagemark.batch) {
                        const pagemarksWithinBatch = this.pagemarksWithinBatch(docMeta, primaryPagemark.batch);
                        pageMetaMutator = () => {
                            for (const pagemarkRef of pagemarksWithinBatch) {
                                delete pagemarkRef.pageMeta.pagemarks[pagemarkRef.id];
                            }
                        };
                    }
                    else {
                        pageMetaMutator = () => delete pageMeta.pagemarks[id];
                    }
                }
                else {
                    log.warn(`No pagemark found for id ${id} for pageNum ${pageNum}`);
                }
            }
            else {
                pageMetaMutator = () => Objects_1.Objects.clear(pageMeta.pagemarks);
            }
            this.doPageMetaMutation(pageMeta, pageMetaMutator);
        });
    }
    static pagemarksWithinBatch(docMeta, batch) {
        const result = [];
        const nrPages = Object.keys(docMeta.pageMetas).length;
        for (let pageIdx = 1; pageIdx <= nrPages; ++pageIdx) {
            const pageMeta = DocMetas_1.DocMetas.getPageMeta(docMeta, pageIdx);
            for (const pagemark of Object.values(pageMeta.pagemarks || {})) {
                if (pagemark.batch === batch) {
                    result.push({ pageMeta, id: pagemark.id });
                }
            }
        }
        return result;
    }
    static doDocMetaMutation(docMeta, pageNum, pagemarkMutator) {
        Preconditions_1.Preconditions.assertPresent(docMeta, "docMeta");
        Preconditions_1.Preconditions.assertPresent(pageNum, "pageNum");
        DocMetas_1.DocMetas.withBatchedMutations(docMeta, () => {
            pagemarkMutator();
            const progress = Math.floor(DocMetas_1.DocMetas.computeProgress(docMeta) * 100);
            docMeta.docInfo.progress = progress;
            docMeta.docInfo.readingPerDay
                = ReadingOverviews_1.ReadingOverviews.compute(Object.values(docMeta.pageMetas));
        });
    }
    static doPageMetaMutation(pageMeta, pageMetaMutator) {
        if (!pageMetaMutator) {
            return;
        }
        const createProgressByMode = () => {
            const result = new HitMap_1.HitMap();
            for (const pagemark of Object.values(pageMeta.pagemarks)) {
                const mode = pagemark.mode || PagemarkMode_1.PagemarkMode.READ;
                result.registerHit(mode, pagemark.percentage);
            }
            return result.toLiteralMap();
        };
        const writeReadingProgress = (preExisting) => {
            const progress = Object.values(pageMeta.pagemarks)
                .map(current => current.percentage)
                .reduce(Reducers_1.Reducers.SUM, 0);
            const progressByMode = createProgressByMode();
            const readingProgress = ReadingProgresses_1.ReadingProgresses.create(progress, progressByMode, preExisting);
            pageMeta.readingProgress[readingProgress.id] = readingProgress;
        };
        const doPreExisting = Dictionaries_1.Dictionaries.empty(pageMeta.readingProgress) && !Dictionaries_1.Dictionaries.empty(pageMeta.pagemarks);
        if (doPreExisting) {
            writeReadingProgress(true);
        }
        pageMetaMutator();
        writeReadingProgress();
    }
    static computeReadingProgressStats(docMetaProviders) {
        for (const docMetaProvider of docMetaProviders) {
            const docMeta = docMetaProvider();
        }
    }
}
Pagemarks.sequences = {
    id: 0,
    batch: 0
};
exports.Pagemarks = Pagemarks;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFnZW1hcmtzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiUGFnZW1hcmtzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsaURBQTRDO0FBQzVDLHlDQUFpRDtBQUNqRCw2Q0FBd0M7QUFDeEMsNENBQXVDO0FBQ3ZDLDZDQUF3QztBQUN4QyxpREFBNEM7QUFDNUMsbURBQThDO0FBQzlDLHVEQUFrRDtBQUNsRCxxREFBMEM7QUFDMUMsaURBQTRDO0FBRTVDLHlDQUFvQztBQUNwQyxvREFBMEQ7QUFDMUQsNkRBQTJFO0FBRTNFLDZDQUF3QztBQUN4QywrQ0FBMEM7QUFFMUMsMkRBQXNEO0FBRXRELDJDQUFzQztBQUN0Qyx5REFBb0Q7QUFFcEQsTUFBTSxHQUFHLEdBQUcsZUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBRTVCLE1BQU0scUJBQXFCLEdBQUcsSUFBSSwyQkFBWSxDQUFDO0lBQzNDLElBQUksRUFBRSxDQUFDO0lBQ1AsR0FBRyxFQUFFLENBQUM7SUFDTixLQUFLLEVBQUUsR0FBRztJQUNWLE1BQU0sRUFBRSxHQUFHO0NBQ2QsQ0FBQyxDQUFDO0FBRUgsTUFBYSxTQUFTO0lBT1gsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUEwQjtRQUM3QyxPQUFPLHFCQUFTLENBQUMsUUFBUSxDQUFDLEVBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUMsQ0FBQztJQUN4RSxDQUFDO0lBUU0sTUFBTSxDQUFDLHVCQUF1QixDQUFDLE9BQWdCLEVBQ2hCLEdBQWUsRUFDZixhQUFxQixHQUFHO1FBRTFELElBQUksR0FBRyxHQUFHLENBQUMsRUFBRTtZQUNULE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQztTQUNwRDtRQUVELE1BQU0sT0FBTyxHQUFHLHVDQUFrQixDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzVDLE1BQU0sS0FBSyxHQUFHLHFCQUFTLENBQUMsUUFBUSxD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RTVDLE1BQU0sT0FBTyxHQUFHLGVBQWUsRUFBRSxDQUFDO1NBSXJDO0lBRUwsQ0FBQzs7QUFyZ0JhLG1CQUFTLEdBQUc7SUFDdEIsRUFBRSxFQUFFLENBQUM7SUFDTCxLQUFLLEVBQUUsQ0FBQztDQUNYLENBQUM7QUFMTiw4QkF5Z0JDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtQYWdlbWFya1JlY3R9IGZyb20gJy4vUGFnZW1hcmtSZWN0JztcbmltcG9ydCB7UGFnZW1hcmssIFBhZ2VtYXJrUmVmfSBmcm9tICcuL1BhZ2VtYXJrJztcbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi9sb2dnZXIvTG9nZ2VyJztcbmltcG9ydCB7SGFzaGNvZGVzfSBmcm9tICcuLi9IYXNoY29kZXMnO1xuaW1wb3J0IHtPYmplY3RzfSBmcm9tICcuLi91dGlsL09iamVjdHMnO1xuaW1wb3J0IHtQYWdlbWFya1R5cGV9IGZyb20gJy4vUGFnZW1hcmtUeXBlJztcbmltcG9ydCB7UGFnZW1hcmtSZWN0c30gZnJvbSAnLi9QYWdlbWFya1JlY3RzJztcbmltcG9ydCB7RGljdGlvbmFyaWVzfSBmcm9tICcuLi91dGlsL0RpY3Rpb25hcmllcyc7XG5pbXBvcnQge3JvdW5kfSBmcm9tICcuLi91dGlsL1BlcmNlbnRhZ2VzJztcbmltcG9ydCB7UGFnZW1hcmtNb2RlfSBmcm9tICcuL1BhZ2VtYXJrTW9kZSc7XG5pbXBvcnQge0RvY01ldGF9IGZyb20gJy4vRG9jTWV0YSc7XG5pbXBvcnQge0RvY01ldGFzfSBmcm9tICcuL0RvY01ldGFzJztcbmltcG9ydCB7aXNQcmVzZW50LCBQcmVjb25kaXRpb25zfSBmcm9tICcuLi9QcmVjb25kaXRpb25zJztcbmltcG9ydCB7SVNPRGF0ZVRpbWVTdHJpbmcsIElTT0RhdGVUaW1lU3RyaW5nc30gZnJvbSAnLi9JU09EYXRlVGltZVN0cmluZ3MnO1xuaW1wb3J0IHtQYWdlTWV0YSwgUGFnZU51bWJlcn0gZnJvbSAnLi9QYWdlTWV0YSc7XG5pbXBvcnQge051bWJlcnN9IGZyb20gXCIuLi91dGlsL051bWJlcnNcIjtcbmltcG9ydCB7UmVkdWNlcnN9IGZyb20gJy4uL3V0aWwvUmVkdWNlcnMnO1xuaW1wb3J0IHtQcm9ncmVzc0J5TW9kZSwgUmVhZGluZ1Byb2dyZXNzfSBmcm9tICcuL1JlYWRpbmdQcm9ncmVzcyc7XG5pbXBvcnQge1JlYWRpbmdQcm9ncmVzc2VzfSBmcm9tICcuL1JlYWRpbmdQcm9ncmVzc2VzJztcbmltcG9ydCB7UHJvdmlkZXJ9IGZyb20gJy4uL3V0aWwvUHJvdmlkZXJzJztcbmltcG9ydCB7SGl0TWFwfSBmcm9tICcuLi91dGlsL0hpdE1hcCc7XG5pbXBvcnQge1JlYWRpbmdPdmVydmlld3N9IGZyb20gJy4vUmVhZGluZ092ZXJ2aWV3cyc7XG5cbmNvbnN0IGxvZyA9IExvZ2dlci5jcmVhdGUoKTtcblxuY29uc3QgREVGQVVMVF9QQUdFTUFSS19SRUNUID0gbmV3IFBhZ2VtYXJrUmVjdCh7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgd2lkdGg6IDEwMCxcbiAgICBoZWlnaHQ6IDEwMFxufSk7XG5cbmV4cG9ydCBjbGFzcyBQYWdlbWFya3Mge1xuXG4gICAgcHVibGljIHN0YXRpYyBzZXF1ZW5jZXMgPSB7XG4gICAgICAgIGlkOiAwLFxuICAgICAgICBiYXRjaDogMFxuICAgIH07XG5cbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZUlEKGNyZWF0ZWQ6IElTT0RhdGVUaW1lU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBIYXNoY29kZXMuY3JlYXRlSUQoe2NyZWF0ZWQsIHNlcXVlbmNlOiB0aGlzLnNlcXVlbmNlcy5pZCsrfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBhZ2VtYXJrcyBvdmVyIHRoZSBnaXZlbiByYW5nZS4gIFdlIGdvIGJhY2sgdG8gZWl0aGVyIHRoZSBmaXJzdFxuICAgICAqIHBhZ2UgdGhhdCBoYXMgYSBwYWdlbWFyayBvciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwZXJjZW50YWdlIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBlbmQgcGFnZSB0byBjcmVhdGUgYSBwYWdlbWFyay5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHVwZGF0ZVBhZ2VtYXJrc0ZvclJhbmdlKGRvY01ldGE6IERvY01ldGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IFBhZ2VOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50YWdlOiBudW1iZXIgPSAxMDAgKTogUmVhZG9ubHlBcnJheTxQYWdlbWFya1JlZj4ge1xuXG4gICAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYWdlIG51bWJlciBtdXN0IGJlIDEgb3IgbW9yZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNyZWF0ZWQgPSBJU09EYXRlVGltZVN0cmluZ3MuY3JlYXRlKCk7XG4gICAgICAgIGNvbnN0IGJhdGNoID0gSGFzaGNvZGVzLmNyZWF0ZUlEKHtjcmVhdGVkLCBpZDogdGhpcy5zZXF1ZW5jZXMuYmF0Y2grK30pO1xuXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZVN0YXJ0UGFnZSA9ICgpID0+IHtcblxuICAgICAgICAgICAgLy8gZmluZCB0aGUgc3RhcnRpbmcgcGFnZSBieSBnb2luZyBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlXG4gICAgICAgICAgICAvLyBkb2N1bWVudCB1bnRpbCB3ZSBmaW5kIHRoZSBmaXJzdCBwYWdlbWFyayBvciB3ZSBoaXQgdGhlIGZpcnN0XG4gICAgICAgICAgICAvLyBwYWdlLlxuXG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IFsgLi4uIE51bWJlcnMucmFuZ2UoMSwgTWF0aC5tYXgoMSwgZW5kIC0gMSkpIF0ucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHIgb2YgcmFuZ2UpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VNZXRhID0gRG9jTWV0YXMuZ2V0UGFnZU1ldGEoZG9jTWV0YSwgcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoRGljdGlvbmFyaWVzLnNpemUocGFnZU1ldGEucGFnZW1hcmtzIHx8IHt9KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHBhZ2UgaGFzIGEgcGFnZW1hcmsgc28gd2Ugc2hvdWxkIHN0YXJ0IGZyb20gdGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGNyZWF0ZVBhZ2VtYXJrUmVjdCA9IChwYWdlTnVtOiBQYWdlTnVtYmVyLCBwZXJjZW50YWdlOiBudW1iZXIgPSAxMDApOiBQYWdlbWFya1JlY3QgfCB1bmRlZmluZWQgPT4ge1xuXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBwYWdlbWFyayB0aGF0IGlzIHRoZSBmdXJ0aGVzdCBkb3duIHRoZSBwYWdlLlxuXG4gICAgICAgICAgICBjb25zdCBwYWdlTWV0YSA9IERvY01ldGFzLmdldFBhZ2VNZXRhKGRvY01ldGEsIHBhZ2VOdW0pO1xuXG4gICAgICAgICAgICBjb25zdCBwYWdlbWFya3MgPSBPYmplY3QudmFsdWVzKHBhZ2VNZXRhLnBhZ2VtYXJrcyB8fCB7fSk7XG5cbiAgICAgICAgICAgIGlmIChwYWdlbWFya3MubGVuZ3RoID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUGFnZW1hcmtSZWN0cy5jcmVhdGVGcm9tUmVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwZXJjZW50YWdlLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTAwXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHRvcDogbnVtYmVyID0gMDtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBwYWdlbWFyayBvZiBwYWdlbWFya3MpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RvcCA9IHBhZ2VtYXJrLnJlY3QudG9wICsgcGFnZW1hcmsucmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3VG9wID4gdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgdG9wID0gbmV3VG9wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFnZW1hcmtzLm1hcChwYWdlbWFyayA9PiBwYWdlbWFyay5wZXJjZW50YWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoUmVkdWNlcnMuU1VNLCAwKSA9PT0gMTAwKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIHBhZ2UgaXMgY29tcGxldGVseSBjb3ZlcmVkIGp1c3QgaWdub3JlIGl0XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBQYWdlbWFya1JlY3RzLmNyZWF0ZUZyb21SZWN0KHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCAtIHRvcCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gY2FsY3VsYXRlU3RhcnRQYWdlKCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYWdlbWFya1JlZltdID0gW107XG5cbiAgICAgICAgRG9jTWV0YXMud2l0aEJhdGNoZWRNdXRhdGlvbnMoZG9jTWV0YSwgKCkgPT4ge1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhZ2VOdW0gb2YgTnVtYmVycy5yYW5nZShzdGFydCwgZW5kKSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdFBlcmNlbnRhZ2UgPVxuICAgICAgICAgICAgICAgICAgICBwYWdlTnVtID09PSBlbmQgPyBwZXJjZW50YWdlIDogMTAwO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IGNyZWF0ZVBhZ2VtYXJrUmVjdChwYWdlTnVtLCByZWN0UGVyY2VudGFnZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVjdCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VtYXJrID0gUGFnZW1hcmtzLmNyZWF0ZSh7Y3JlYXRlZCwgcmVjdCwgYmF0Y2h9KTtcblxuICAgICAgICAgICAgICAgICAgICBQYWdlbWFya3MudXBkYXRlUGFnZW1hcmsoZG9jTWV0YSwgcGFnZU51bSwgcGFnZW1hcmspO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtwYWdlTnVtLCBwYWdlbWFya30pO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBwYWdlbWFyayB3aXRoIHRoZSBjcmVhdGVkIHRpbWUsIGFuZCBvdGhlciBtYW5kYXRvcnkgZmllbGRzXG4gICAgICogYWRkZWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZShvcHRzOiBQYXJ0aWFsPFBhZ2VtYXJrT3B0aW9ucz4gPSB7fSk6IFBhZ2VtYXJrIHtcblxuICAgICAgICBjb25zdCBvcHRpb25zOiBQYWdlbWFya09wdGlvbnMgPSBPYmplY3RzLmRlZmF1bHRzKCBvcHRzLCB7XG5cbiAgICAgICAgICAgIC8vIGp1c3Qgc2V0IGRvY01ldGEgcGFnZU1hcmtUeXBlID0gUGFnZW1hcmtUeXBlLlNJTkdMRV9DT0xVTU4gYnlcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgZm9yIG5vdyB1bnRpbCB3ZSBhZGQgbXVsdGlwbGUgY29sdW1uIHR5cGVzIGFuZCBoYW5kbGVcbiAgICAgICAgICAgIC8vIHRoZW0gcHJvcGVybHkuXG5cbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgbmVlZHMgdG8gYmUgcmVhZCBmcm9tIHRoZSBkb2NJbmZvIHNldHRpbmcgZm9yIHRoaXNcbiAgICAgICAgICAgIC8vIGRvY3VtZW50IGFuZCB0aGUgZGVmYXVsdCBoZXJlXG5cbiAgICAgICAgICAgIHR5cGU6IFBhZ2VtYXJrVHlwZS5TSU5HTEVfQ09MVU1OLFxuXG4gICAgICAgICAgICBjb2x1bW46IDAsXG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qga2V5T3B0aW9ucyA9IFBhZ2VtYXJrcy5jcmVhdGVLZXlPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChrZXlPcHRpb25zLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHNwZWNpZnkgZWl0aGVyIHJlY3Qgb3IgcGVyY2VudGFnZS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5T3B0aW9ucy5jb3VudCA9PT0gMSkge1xuXG4gICAgICAgICAgICBpZiAoa2V5T3B0aW9ucy5oYXNQZXJjZW50YWdlKSB7XG4gICAgICAgICAgICAgICAga2V5T3B0aW9ucy5yZWN0ID0gUGFnZW1hcmtSZWN0cy5jcmVhdGVGcm9tUGVyY2VudGFnZShrZXlPcHRpb25zLnBlcmNlbnRhZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoa2V5T3B0aW9ucy5oYXNSZWN0KSB7XG4gICAgICAgICAgICAgICAga2V5T3B0aW9ucy5wZXJjZW50YWdlID0ga2V5T3B0aW9ucy5yZWN0LnRvUGVyY2VudGFnZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm91bmQoa2V5T3B0aW9ucy5wZXJjZW50YWdlKSAhPT0gcm91bmQoa2V5T3B0aW9ucy5yZWN0LnRvUGVyY2VudGFnZSgpKSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gXCJQZXJjZW50YWdlIGFuZCByZWN0IGFyZSBub3QgdGhlIHNhbWVcIjtcbiAgICAgICAgICAgIGxvZy53YXJuKG1zZywga2V5T3B0aW9ucy5wZXJjZW50YWdlLCBrZXlPcHRpb25zLnJlY3QsIGtleU9wdGlvbnMucmVjdC50b1BlcmNlbnRhZ2UoKSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNyZWF0ZWQgPSBvcHRpb25zLmNyZWF0ZWQgfHwgSVNPRGF0ZVRpbWVTdHJpbmdzLmNyZWF0ZSgpO1xuXG4gICAgICAgIGNvbnN0IGJhdGNoID0gb3B0aW9ucy5iYXRjaCB8fCBIYXNoY29kZXMuY3JlYXRlSUQoe2NyZWF0ZWQsIGlkOiB0aGlzLnNlcXVlbmNlcy5iYXRjaCsrfSk7XG5cbiAgICAgICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCBQYWdlbWFya01vZGUuUkVBRDtcblxuICAgICAgICByZXR1cm4gbmV3IFBhZ2VtYXJrKHtcblxuICAgICAgICAgICAgLy8gcGVyLXBhZ2VtYXJrIGZpZWxkcy5cbiAgICAgICAgICAgIGlkOiBQYWdlbWFya3MuY3JlYXRlSUQoY3JlYXRlZCksXG4gICAgICAgICAgICBjcmVhdGVkLFxuXG4gICAgICAgICAgICAvLyB0aGUgcmVzdCBhcmUgZnJvbSBvcHRpb25zLlxuICAgICAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlLFxuICAgICAgICAgICAgcGVyY2VudGFnZToga2V5T3B0aW9ucy5wZXJjZW50YWdlLFxuICAgICAgICAgICAgY29sdW1uOiBvcHRpb25zLmNvbHVtbixcbiAgICAgICAgICAgIHJlY3Q6IGtleU9wdGlvbnMucmVjdCxcbiAgICAgICAgICAgIGJhdGNoLFxuICAgICAgICAgICAgbW9kZVxuXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge0tleVBhZ2VtYXJrT3B0aW9uc31cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBjcmVhdGVLZXlPcHRpb25zKG9wdGlvbnM6IFBhZ2VtYXJrT3B0aW9ucyk6IEtleVBhZ2VtYXJrT3B0aW9ucyB7XG5cbiAgICAgICAgY29uc3Qga2V5T3B0aW9uczogS2V5UGFnZW1hcmtPcHRpb25zID0ge1xuICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgICBoYXNQZXJjZW50YWdlOiBmYWxzZSxcbiAgICAgICAgICAgIGhhc1JlY3Q6IGZhbHNlLFxuICAgICAgICAgICAgcmVjdDogb3B0aW9ucy5yZWN0LFxuICAgICAgICAgICAgcGVyY2VudGFnZTogb3B0aW9ucy5wZXJjZW50YWdlXG4gICAgICAgIH07XG5cbiAgICAgICAga2V5T3B0aW9ucy5oYXNQZXJjZW50YWdlID0gXCJwZXJjZW50YWdlXCIgaW4gb3B0aW9ucztcbiAgICAgICAga2V5T3B0aW9ucy5oYXNSZWN0ID0gXCJyZWN0XCIgaW4gb3B0aW9ucztcblxuICAgICAgICBpZiAoa2V5T3B0aW9ucy5oYXNQZXJjZW50YWdlKSB7XG4gICAgICAgICAgICArK2tleU9wdGlvbnMuY291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5T3B0aW9ucy5oYXNSZWN0KSB7XG4gICAgICAgICAgICArK2tleU9wdGlvbnMuY291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5T3B0aW9ucztcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyB1cGdyYWRlKHBhZ2VtYXJrczoge1tpZDogc3RyaW5nXTogUGFnZW1hcmt9KSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiB7W2lkOiBzdHJpbmddOiBQYWdlbWFya30gPSB7fTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgcGFnZW1hcmtzKTtcblxuICAgICAgICBEaWN0aW9uYXJpZXMuZm9yRGljdChyZXN1bHQsIChrZXksIHBhZ2VtYXJrKSA9PiB7XG5cbiAgICAgICAgICAgIGlmICghIHBhZ2VtYXJrLnJlY3QpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwYWdlbWFyay5wZXJjZW50YWdlID49IDAgJiYgcGFnZW1hcmsucGVyY2VudGFnZSA8PSAxMDApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBub3cgcmVjdCBidXQgd2UgY2FuIGJ1aWxkIG9uZSBmcm9tIHRoZSBwZXJjZW50YWdlLlxuICAgICAgICAgICAgICAgICAgICBwYWdlbWFyay5yZWN0ID0gUGFnZW1hcmtSZWN0cy5jcmVhdGVGcm9tUGVyY2VudGFnZShwYWdlbWFyay5wZXJjZW50YWdlKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISBwYWdlbWFyay5pZCkge1xuICAgICAgICAgICAgICAgIC8vIGxvZy5kZWJ1ZyhcIlBhZ2VtYXJrIGdpdmVuIElEXCIpO1xuICAgICAgICAgICAgICAgIHBhZ2VtYXJrLmlkID0ga2V5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoICEgcGFnZW1hcmsubW9kZSkge1xuICAgICAgICAgICAgICAgIC8vIGxvZy5kZWJ1ZyhcIlVzaW5nIGRlZmF1bHQgcGFnZW1hcmsgbW9kZS5cIik7XG4gICAgICAgICAgICAgICAgcGFnZW1hcmsubW9kZSA9IFBhZ2VtYXJrTW9kZS5SRUFEO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoICEgaXNQcmVzZW50KHBhZ2VtYXJrLnBlcmNlbnRhZ2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9nLmRlYnVnKFwiTm8gcGFnZW1hcmsgcGVyY2VudGFnZS4gQXNzaWduaW5nIHplcm8uXCIpO1xuICAgICAgICAgICAgICAgIHBhZ2VtYXJrLnBlcmNlbnRhZ2UgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcGFnZW1hcmtzIG9uIHRoZSBnaXZlbiBwYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhZ2VtYXJrIFRoZSBwYWdlbWFyayB0byB1cGRhdGUuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyB1cGRhdGVQYWdlbWFyayhkb2NNZXRhOiBEb2NNZXRhLCBwYWdlTnVtOiBudW1iZXIsIHBhZ2VtYXJrOiBQYWdlbWFyaykge1xuXG4gICAgICAgIHRoaXMuZG9Eb2NNZXRhTXV0YXRpb24oZG9jTWV0YSwgcGFnZU51bSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFnZU1ldGEgPSBEb2NNZXRhcy5nZXRQYWdlTWV0YShkb2NNZXRhLCBwYWdlTnVtKTtcblxuICAgICAgICAgICAgdGhpcy5kb1BhZ2VNZXRhTXV0YXRpb24ocGFnZU1ldGEsICgpID0+IHtcbiAgICAgICAgICAgICAgICBwYWdlTWV0YS5wYWdlbWFya3NbcGFnZW1hcmsuaWRdID0gcGFnZW1hcms7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhlIHBhZ2VtYXJrcyB3aXRoIGEgbmV3IHBhZ2VtYXJrIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICAgKiByZXBsYWNlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHJlcGxhY2VQYWdlbWFyayhkb2NNZXRhOiBEb2NNZXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VtYXJrUHRyOiBQYWdlbWFya1BUUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBSZXBsYWNlUGFnZW1hcmtPcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3QgcGFnZW1hcmtzVG9NdXRhdGUgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgIC8vIHRoZSBwYWdlbWFya3MgdG8gbXV0YXRlLlxuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBQYWdlbWFya1BhZ2VNZXRhUmVmW10gPSBbXTtcblxuICAgICAgICAgICAgaWYgKHBhZ2VtYXJrUHRyLnJlZikge1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc2luY2Ugd2UncmUgZ2l2ZW4gYSBwYWdlbWFyayBkaXJlY3RseSBzaG91bGRuJ3RcbiAgICAgICAgICAgICAgICAvLyB3ZSBhbHNvIHJlc29sdmUgYnkgdGhlIGJhdGNoP1xuXG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgcGFnZW1hcmtzIGJ5IHJlZi4uLlxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VNZXRhID0gRG9jTWV0YXMuZ2V0UGFnZU1ldGEoZG9jTWV0YSwgcGFnZW1hcmtQdHIucmVmLnBhZ2VOdW0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtwYWdlTWV0YSwgaWQ6IHBhZ2VtYXJrUHRyLnJlZi5wYWdlbWFyay5pZH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFnZW1hcmtQdHIuYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBwYWdlbWFya3MgYnkgYmF0Y2guLi5cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi50aGlzLnBhZ2VtYXJrc1dpdGhpbkJhdGNoKGRvY01ldGEsIHBhZ2VtYXJrUHRyLmJhdGNoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBmaW5kIHdoYXQgd2Ugc2hvdWxkIG11dGF0ZVxuICAgICAgICBjb25zdCBwYWdlbWFya1JlZnMgPSBwYWdlbWFya3NUb011dGF0ZSgpO1xuXG4gICAgICAgIC8vIG5vdyBwZXJmb3JtIHRoZSBtdXRhdGlvbnMgb24gdGhlIHBhZ2VtYXJrcy4gIEF0IHRoZSBlbmQgd2Ugc2hvdWxkXG4gICAgICAgIC8vIFNUSUxMIGNvbXB1dGUgdGhlIHByb2dyZXNzIG9uIHRoZSBkb2N1bWVudCBhcyB3ZSBhcmUgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHR5cGVzIG9uIHRoZSBwYWdlbWFyay5cbiAgICAgICAgRG9jTWV0YXMud2l0aEJhdGNoZWRNdXRhdGlvbnMoZG9jTWV0YSwgKCkgPT4ge1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiBwYWdlbWFya1JlZnMpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJQYWdlbWFyayA9IHJlZi5wYWdlTWV0YS5wYWdlbWFya3NbcmVmLmlkXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhZ2VtYXJrID0gbmV3IFBhZ2VtYXJrKGN1cnJQYWdlbWFyayk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BhZ2VtYXJrLm1vZGUgPSBvcHRpb25zLm1vZGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kb1BhZ2VNZXRhTXV0YXRpb24ocmVmLnBhZ2VNZXRhLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5wYWdlTWV0YS5wYWdlbWFya3NbcmVmLmlkXSA9IG5ld1BhZ2VtYXJrO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBXaGVuIGlkIGlzIHNwZWNpZmllZCB3ZSBkZWxldGUganVzdCBhIHNwZWNpZmljIHBhZ2VtYXJrLFxuICAgICAqIG90aGVyd2lzZSB3ZSBkZWxldGUgYWxsIG9mIHRoZW0uXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBkZWxldGVQYWdlbWFyayhkb2NNZXRhOiBEb2NNZXRhLCBwYWdlTnVtOiBudW1iZXIsIGlkPzogc3RyaW5nKSB7XG5cbiAgICAgICAgdGhpcy5kb0RvY01ldGFNdXRhdGlvbihkb2NNZXRhLCBwYWdlTnVtLCAoKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHBhZ2VNZXRhID0gRG9jTWV0YXMuZ2V0UGFnZU1ldGEoZG9jTWV0YSwgcGFnZU51bSk7XG5cbiAgICAgICAgICAgIGxldCBwYWdlTWV0YU11dGF0b3I6IFZPSURfRlVOQ1RJT04gfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGlmIChpZCkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcHJpbWFyeVBhZ2VtYXJrID0gcGFnZU1ldGEucGFnZW1hcmtzW2lkXTtcblxuICAgICAgICAgICAgICAgIGlmIChwcmltYXJ5UGFnZW1hcmspIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJpbWFyeVBhZ2VtYXJrLmJhdGNoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgcGFnZW1hcmsgaGFzIGEgYmF0Y2ggd2UgaGF2ZSB0byBkZWxldGUgZXZlcnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIHNhbWUgYmF0Y2hcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZW1hcmtzV2l0aGluQmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMucGFnZW1hcmtzV2l0aGluQmF0Y2goZG9jTWV0YSwgcHJpbWFyeVBhZ2VtYXJrLmJhdGNoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZU1ldGFNdXRhdG9yID0gKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYWdlbWFya1JlZiBvZiBwYWdlbWFya3NXaXRoaW5CYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFnZW1hcmtSZWYucGFnZU1ldGEucGFnZW1hcmtzW3BhZ2VtYXJrUmVmLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlTWV0YU11dGF0b3IgPSAoKSA9PiBkZWxldGUgcGFnZU1ldGEucGFnZW1hcmtzW2lkXTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihgTm8gcGFnZW1hcmsgZm91bmQgZm9yIGlkICR7aWR9IGZvciBwYWdlTnVtICR7cGFnZU51bX1gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFnZU1ldGFNdXRhdG9yID0gKCkgPT4gT2JqZWN0cy5jbGVhcihwYWdlTWV0YS5wYWdlbWFya3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRvUGFnZU1ldGFNdXRhdGlvbihwYWdlTWV0YSwgcGFnZU1ldGFNdXRhdG9yKTtcblxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjYW4gYWxsIHRoZSBwYWdlbWFya3MgZmluZGluZyBvbmVzIHdpdGggdGhlIHNhbWUgYmF0Y2guXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGFnZW1hcmtzV2l0aGluQmF0Y2goZG9jTWV0YTogRG9jTWV0YSwgYmF0Y2g6IHN0cmluZyk6IFJlYWRvbmx5QXJyYXk8UGFnZW1hcmtQYWdlTWV0YVJlZj4ge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGNvbnN0IG5yUGFnZXMgPSBPYmplY3Qua2V5cyhkb2NNZXRhLnBhZ2VNZXRhcykubGVuZ3RoO1xuXG4gICAgICAgIGZvciAobGV0IHBhZ2VJZHggPSAxOyBwYWdlSWR4IDw9IG5yUGFnZXM7ICsrcGFnZUlkeCkge1xuICAgICAgICAgICAgY29uc3QgcGFnZU1ldGEgPSBEb2NNZXRhcy5nZXRQYWdlTWV0YShkb2NNZXRhLCBwYWdlSWR4KTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBwYWdlbWFyayBvZiBPYmplY3QudmFsdWVzKHBhZ2VNZXRhLnBhZ2VtYXJrcyB8fCB7fSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwYWdlbWFyay5iYXRjaCA9PT0gYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe3BhZ2VNZXRhLCBpZDogcGFnZW1hcmsuaWR9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGRvRG9jTWV0YU11dGF0aW9uKGRvY01ldGE6IERvY01ldGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZU51bTogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VtYXJrTXV0YXRvcjogKCkgPT4gdm9pZCk6IHZvaWQge1xuXG4gICAgICAgIFByZWNvbmRpdGlvbnMuYXNzZXJ0UHJlc2VudChkb2NNZXRhLCBcImRvY01ldGFcIik7XG4gICAgICAgIFByZWNvbmRpdGlvbnMuYXNzZXJ0UHJlc2VudChwYWdlTnVtLCBcInBhZ2VOdW1cIik7XG5cbiAgICAgICAgRG9jTWV0YXMud2l0aEJhdGNoZWRNdXRhdGlvbnMoZG9jTWV0YSwgKCkgPT4ge1xuXG4gICAgICAgICAgICBwYWdlbWFya011dGF0b3IoKTtcblxuICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLmZsb29yKERvY01ldGFzLmNvbXB1dGVQcm9ncmVzcyhkb2NNZXRhKSAqIDEwMCk7XG4gICAgICAgICAgICBkb2NNZXRhLmRvY0luZm8ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcblxuICAgICAgICAgICAgZG9jTWV0YS5kb2NJbmZvLnJlYWRpbmdQZXJEYXlcbiAgICAgICAgICAgICAgICA9IFJlYWRpbmdPdmVydmlld3MuY29tcHV0ZShPYmplY3QudmFsdWVzKGRvY01ldGEucGFnZU1ldGFzKSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNdXRhdGUgdGhlIHBhZ2VtYXJrcyBvbiB0aGUgUGFnZU1ldGEgYW5kIGFsc28gdXBkYXRlIHRoZSByZWFkaW5nUHJvZ3Jlc3NcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBkb1BhZ2VNZXRhTXV0YXRpb24ocGFnZU1ldGE6IFBhZ2VNZXRhLCBwYWdlTWV0YU11dGF0b3I/OiBWT0lEX0ZVTkNUSU9OKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKCEgcGFnZU1ldGFNdXRhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjcmVhdGVQcm9ncmVzc0J5TW9kZSA9ICgpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEhpdE1hcCgpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhZ2VtYXJrIG9mIE9iamVjdC52YWx1ZXMocGFnZU1ldGEucGFnZW1hcmtzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGUgPSBwYWdlbWFyay5tb2RlIHx8IFBhZ2VtYXJrTW9kZS5SRUFEO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWdpc3RlckhpdChtb2RlLCBwYWdlbWFyay5wZXJjZW50YWdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b0xpdGVyYWxNYXAoKTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHdyaXRlUmVhZGluZ1Byb2dyZXNzID0gKHByZUV4aXN0aW5nPzogYm9vbGVhbikgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE9iamVjdC52YWx1ZXMocGFnZU1ldGEucGFnZW1hcmtzKVxuICAgICAgICAgICAgICAgIC5tYXAoY3VycmVudCA9PiBjdXJyZW50LnBlcmNlbnRhZ2UpXG4gICAgICAgICAgICAgICAgLnJlZHVjZShSZWR1Y2Vycy5TVU0sIDApO1xuXG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzc0J5TW9kZSA9IGNyZWF0ZVByb2dyZXNzQnlNb2RlKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlYWRpbmdQcm9ncmVzcyA9XG4gICAgICAgICAgICAgICAgUmVhZGluZ1Byb2dyZXNzZXMuY3JlYXRlKHByb2dyZXNzLCBwcm9ncmVzc0J5TW9kZSwgcHJlRXhpc3RpbmcpO1xuXG4gICAgICAgICAgICBwYWdlTWV0YS5yZWFkaW5nUHJvZ3Jlc3NbcmVhZGluZ1Byb2dyZXNzLmlkXSA9IHJlYWRpbmdQcm9ncmVzcztcblxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGRvUHJlRXhpc3RpbmcgPVxuICAgICAgICAgICAgRGljdGlvbmFyaWVzLmVtcHR5KHBhZ2VNZXRhLnJlYWRpbmdQcm9ncmVzcykgJiYgISBEaWN0aW9uYXJpZXMuZW1wdHkocGFnZU1ldGEucGFnZW1hcmtzKTtcblxuICAgICAgICBpZiAoZG9QcmVFeGlzdGluZykge1xuICAgICAgICAgICAgd3JpdGVSZWFkaW5nUHJvZ3Jlc3ModHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYWdlTWV0YU11dGF0b3IoKTtcblxuICAgICAgICB3cml0ZVJlYWRpbmdQcm9ncmVzcygpO1xuXG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjb21wdXRlUmVhZGluZ1Byb2dyZXNzU3RhdHMoZG9jTWV0YVByb3ZpZGVyczogUmVhZG9ubHlBcnJheTxQcm92aWRlcjxEb2NNZXRhPj4pIHtcblxuICAgICAgICAvLyBUT0RPOiB3ZSBkb24ndCBhaHZlIHRoZSBwYWdlTWV0YSBoZXJlIHNvIG1heWJlIHdlIGNvdWxkIGp1c3Qgd3JpdGVcbiAgICAgICAgLy8gb3V0IGEgbWluaW1hbCB2ZWN0b3Igb2YgZGF5ICsgbnVtYmVyIG9mIHRoZSBudW1iZXIgb2YgcGFnZXMgd2UndmVcbiAgICAgICAgLy8gcmVhZCB0byB0aGUgRG9jSW5mb1xuXG4gICAgICAgIGZvciAoY29uc3QgZG9jTWV0YVByb3ZpZGVyIG9mIGRvY01ldGFQcm92aWRlcnMpIHtcblxuICAgICAgICAgICAgY29uc3QgZG9jTWV0YSA9IGRvY01ldGFQcm92aWRlcigpO1xuXG5cblxuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuaW50ZXJmYWNlIFBhZ2VtYXJrUGFnZU1ldGFSZWYge1xuICAgIHJlYWRvbmx5IHBhZ2VNZXRhOiBQYWdlTWV0YTtcbiAgICByZWFkb25seSBpZDogc3RyaW5nO1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZW1hcmtPcHRpb25zIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHBhZ2VtYXJrIHdlJ3JlIHdvcmtpbmcgd2l0aC5cbiAgICAgKi9cbiAgICB0eXBlOiBQYWdlbWFya1R5cGU7XG5cbiAgICAvKipcbiAgICAgKi9cbiAgICByZWN0OiBQYWdlbWFya1JlY3Q7XG5cbiAgICAvKipcbiAgICAgKi9cbiAgICBwZXJjZW50YWdlOiBudW1iZXI7XG5cbiAgICBjb2x1bW46IG51bWJlcjtcblxuICAgIGJhdGNoPzogc3RyaW5nO1xuXG4gICAgY3JlYXRlZD86IHN0cmluZztcblxuICAgIG1vZGU/OiBQYWdlbWFya01vZGU7XG5cbn1cblxuLyoqXG4gKiBBIHBvaW50ZXIgdG8gYSBwYWdlbWFyayBlaXRoZXIgYnkgaWQgLCBiYXRjaC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYWdlbWFya1BUUiB7XG5cbiAgICByZWFkb25seSByZWY/OiBQYWdlbWFya1JlZjtcblxuICAgIHJlYWRvbmx5IGJhdGNoPzogc3RyaW5nO1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVwbGFjZVBhZ2VtYXJrT3B0aW9ucyB7XG5cbiAgICByZWFkb25seSBtb2RlPzogUGFnZW1hcmtNb2RlO1xuXG59XG5cbi8qKlxuICogVGhlIGtleSAvIGltcG9ydGFudCBvcHRpb25zIHdoZW4gY3JlYXRpbmcgYSBQYWdlbWFyay5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLZXlQYWdlbWFya09wdGlvbnMge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIG51bWJlciBvZiBrZXkgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb3VudDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSB3aGVuIHdlIGhhdmUgdGhlIHBlcmNlbnRhZ2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNQZXJjZW50YWdlOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSB3aGVuIHdlIGhhdmUgdGhlIHJlY3QuXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNSZWN0OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICovXG4gICAgcmVjdDogUGFnZW1hcmtSZWN0O1xuXG4gICAgLyoqXG4gICAgICovXG4gICAgcGVyY2VudGFnZTogbnVtYmVyO1xuXG59XG5cbmV4cG9ydCB0eXBlIFZPSURfRlVOQ1RJT04gPSAoKSA9PiB2b2lkO1xuIl19