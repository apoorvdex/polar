"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Preconditions_1 = require("../Preconditions");
const Optional_1 = require("./ts/Optional");
class Arrays {
    static first(values) {
        if (values.length === 0) {
            return undefined;
        }
        return values[0];
    }
    static last(values) {
        if (values.length === 0) {
            return undefined;
        }
        return values[values.length - 1];
    }
    static sample(values, count) {
        if (count === 0) {
            return [];
        }
        if (values.length <= count) {
            return values;
        }
        const result = [];
        const gap = Math.floor(values.length / count);
        for (let idx = 0; idx < values.length; idx += gap) {
            result.push(values[idx]);
        }
        return result;
    }
    static toDict(val) {
        const isObject = typeof val === "object";
        const isArray = val instanceof Array;
        if (!isObject && !isArray) {
            throw new Error("Neither an object or an array.");
        }
        if (isObject && !isArray) {
            return val;
        }
        if (!isArray) {
            throw new Error("Not an array");
        }
        let result = {};
        let arrayVal = val;
        for (let idx = 0; idx < arrayVal.length; ++idx) {
            result[idx] = arrayVal[idx];
        }
        return result;
    }
    static createSiblings(arrayLikeObject) {
        Preconditions_1.Preconditions.assertNotNull(arrayLikeObject, "arrayLikeObject");
        const result = [];
        for (let idx = 0; idx < arrayLikeObject.length; ++idx) {
            result.push(new ArrayPosition(Optional_1.Optional.of(arrayLikeObject[idx - 1]).getOrUndefined(), arrayLikeObject[idx], Optional_1.Optional.of(arrayLikeObject[idx + 1]).getOrUndefined()));
        }
        return result;
    }
    static createBatches(input, batchSize) {
        const result = [];
        let batch = [];
        input.forEach(current => {
            if (batch.length === batchSize) {
                result.push(batch);
                batch = [];
            }
            batch.push(current);
        });
        if (batch.length > 0) {
            result.push(batch);
        }
        return result;
    }
    static asyncForEach(items, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const item of items) {
                yield callback(item);
            }
        });
    }
    static shuffle(...input) {
        const arr = Object.assign([], input);
        let j, x, i;
        for (i = arr.length - 1; i > 0; i--) {
            j = Math.floor(Math.random() * (i + 1));
            x = arr[i];
            arr[i] = arr[j];
            arr[j] = x;
        }
        return arr;
    }
    static head(input, limit) {
        limit = Math.min(limit, input.length);
        const result = [];
        for (let idx = 0; idx < limit; ++idx) {
            result[idx] = input[idx];
        }
        return result;
    }
}
exports.Arrays = Arrays;
class ArrayPosition {
    constructor(prev, curr, next) {
        this.prev = prev;
        this.curr = curr;
        this.next = next;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXJyYXlzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiQXJyYXlzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxvREFBK0M7QUFDL0MsNENBQXVDO0FBRXZDLE1BQWEsTUFBTTtJQUVSLE1BQU0sQ0FBQyxLQUFLLENBQUksTUFBd0I7UUFFM0MsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNyQixPQUFPLFNBQVMsQ0FBQztTQUNwQjtRQUVELE9BQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRXJCLENBQUM7SUFFTSxNQUFNLENBQUMsSUFBSSxDQUFJLE1BQXdCO1FBRTFDLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDckIsT0FBTyxTQUFTLENBQUM7U0FDcEI7UUFFRCxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBRXJDLENBQUM7SUFNTSxNQUFNLENBQUMsTUFBTSxDQUFJLE1BQVcsRUFBRSxLQUFhO1FBRTlDLElBQUksS0FBSyxLQUFLLENBQUMsRUFBRTtZQUNiLE9BQU8sRUFBRSxDQUFDO1NBQ2I7UUFFRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLElBQUksS0FBSyxFQUFFO1lBRXhCLE9BQU8sTUFBTSxDQUFDO1NBQ2pCO1FBRUQsTUFBTSxNQUFNLEdBQVEsRUFBRSxDQUFDO1FBRXZCLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQztRQUU5QyxLQUFLLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUksR0FBRyxFQUFFO1lBQy9DLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDNUI7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUVsQixD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LENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2pDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3hDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDWCxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2hCLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDZDtRQUVELE9BQU8sR0FBRyxDQUFDO0lBRWYsQ0FBQztJQU1NLE1BQU0sQ0FBQyxJQUFJLENBQUksS0FBdUIsRUFBRSxLQUFhO1FBR3hELEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFdEMsTUFBTSxNQUFNLEdBQVEsRUFBRSxDQUFDO1FBRXZCLEtBQUssSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxLQUFLLEVBQUUsRUFBRSxHQUFHLEVBQUU7WUFDbEMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUM1QjtRQUVELE9BQU8sTUFBTSxDQUFDO0lBRWxCLENBQUM7Q0FFSjtBQTdNRCx3QkE2TUM7QUFZRCxNQUFNLGFBQWE7SUFRZixZQUFZLElBQW1CLEVBQUUsSUFBTyxFQUFFLElBQW1CO1FBQ3pELElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ3JCLENBQUM7Q0FFSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UHJlY29uZGl0aW9uc30gZnJvbSAnLi4vUHJlY29uZGl0aW9ucyc7XG5pbXBvcnQge09wdGlvbmFsfSBmcm9tICcuL3RzL09wdGlvbmFsJztcblxuZXhwb3J0IGNsYXNzIEFycmF5cyB7XG5cbiAgICBwdWJsaWMgc3RhdGljIGZpcnN0PFQ+KHZhbHVlczogUmVhZG9ubHlBcnJheTxUPik6IFQgfCB1bmRlZmluZWQge1xuXG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlc1swXTtcblxuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgbGFzdDxUPih2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8VD4pOiBUIHwgdW5kZWZpbmVkIHtcblxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGFrZSBOIHNhbXBsZXMgZnJvbSB0aGUgZ2l2ZW4gaW5wdXQuXG4gICAgICogQHBhcmFtIHZhbHVlc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc2FtcGxlPFQ+KHZhbHVlczogVFtdLCBjb3VudDogbnVtYmVyKSB7XG5cbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA8PSBjb3VudCkge1xuICAgICAgICAgICAgLy8gd2UncmUgZG9uZSBhbmQgYWxyZWFkeSBoYXZlIGVub3VnaCBzYW1wbGVzLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogVFtdID0gW107XG5cbiAgICAgICAgY29uc3QgZ2FwID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gY291bnQpO1xuXG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHZhbHVlcy5sZW5ndGg7IGlkeCArPSBnYXApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlc1tpZHhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIGFycmF5IHRvIGEgZGljdGlvbmFyeS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHRvRGljdCh2YWw6IHt9IHwgYW55W10pOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG5cbiAgICAgICAgY29uc3QgaXNPYmplY3QgPSB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiO1xuICAgICAgICBjb25zdCBpc0FycmF5ID0gdmFsIGluc3RhbmNlb2YgQXJyYXk7XG5cbiAgICAgICAgaWYgKCEgaXNPYmplY3QgJiYgISBpc0FycmF5KSB7XG4gICAgICAgICAgICAvLyBvbmx5IG5lZWRlZCBpZiB3ZSdyZSBjYWxsZWQgZnJvbSBKUy4gIE90aGVyd2lzZSB0aGUgY29tcGlsZXJcbiAgICAgICAgICAgIC8vIHdpbGwgY2hlY2sgdGhlIHR5cGUuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZWl0aGVyIGFuIG9iamVjdCBvciBhbiBhcnJheS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZihpc09iamVjdCAmJiAhIGlzQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgZG9uZSBhcyB0aGlzIGlzIGEgZGljdGlvbmFyeSB0aG91Z2ggd2UgbWlnaHQgY29uc2lkZXJcbiAgICAgICAgICAgIC8vIG1ha2luZyB0aGlzIGFcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISBpc0FycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYW4gYXJyYXlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0OiB7W2tleTogc3RyaW5nXTogYW55fSA9IHt9O1xuXG4gICAgICAgIGxldCBhcnJheVZhbDogYW55W10gPSA8YW55W10+dmFsO1xuXG4gICAgICAgIGZvcihsZXQgaWR4ID0gMDsgaWR4IDwgYXJyYXlWYWwubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgcmVzdWx0W2lkeF0gPSBhcnJheVZhbFtpZHhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdvIG92ZXIgdGhlIGFycmF5LWxpa2Ugb2JqZWN0IGFuZCByZXR1cm4gdHVwbGVzIHdpdGggcHJldiwgY3VyciwgYW5kIG5leHRcbiAgICAgKiBwcm9wZXJ0aWVzIHNvIHRoYXQgd2UgY2FuIHBlZWsgYXQgc2libGluZ3MgZWFzaWx5LiAgSWYgdGhlIHByZXYgYW5kIC8gb3JcbiAgICAgKiBuZXh0IGFyZSBub3QgcHJlc2VudCB0aGVzZSB2YWx1ZXMgYXJlIG51bGwuXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIGZvciBhbGdvcml0aG1zIHRoYXQgbmVlZCB0byBwZWVrIGFoZWFkIG9yIGJlaGluZFxuICAgICAqIGluc2lkZSBhbiBpdGVyYXRpdmUgYWxnb3JpdGhtXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVTaWJsaW5nczxUPihhcnJheUxpa2VPYmplY3Q6IFRbXSkge1xuXG4gICAgICAgIFByZWNvbmRpdGlvbnMuYXNzZXJ0Tm90TnVsbChhcnJheUxpa2VPYmplY3QsIFwiYXJyYXlMaWtlT2JqZWN0XCIpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB7QXJyYXk8QXJyYXlQb3NpdGlvbj59XG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGFycmF5TGlrZU9iamVjdC5sZW5ndGg7ICsraWR4KSB7XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBBcnJheVBvc2l0aW9uPFQ+KFxuICAgICAgICAgICAgICAgIE9wdGlvbmFsLm9mKGFycmF5TGlrZU9iamVjdFtpZHgtMV0pLmdldE9yVW5kZWZpbmVkKCksXG4gICAgICAgICAgICAgICAgYXJyYXlMaWtlT2JqZWN0W2lkeF0sXG4gICAgICAgICAgICAgICAgT3B0aW9uYWwub2YoYXJyYXlMaWtlT2JqZWN0W2lkeCsxXSkuZ2V0T3JVbmRlZmluZWQoKVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlIHRoZSBpbnB1dCBhbmQgcmV0dXJuIGl0IGFzIGJhdGNoIG9mIGxpc3RzIGJhc2VkIG9uIHRoZSBzaXplLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBiYXRjaFNpemUgaXMgMiwgYW5kIHRoZSBpbnB1dCBpcyBhIGFycmF5IG9mXG4gICAgICogaW50ZWdlcnMsXG4gICAgICogYW5kIHdlJ3JlIGdpdmVuIFsxLCAyLCAzLCA0LCA1XSB3ZSB3aWxsIHJldHVybiBbWzEsMl0sWzMsNF0sWzVdXVxuICAgICAqXG4gICAgICogSWYgdHJhaWxpbmcgaXMgZmFsc2Ugd2Ugb25seSByZXR1cm4gY29sbGVjdGlvbnMgdGhhdCBhcmUgZnVsbCwgbm90XG4gICAgICogcGFydGlhbC4gVGhpcyBpcyB0aGUgbGFzdCBmZXcgaWYgdGhleSBkb24ndCBlcXVhbCB0aGUgc2l6ZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlQmF0Y2hlczxUPihpbnB1dDogVFtdLCBiYXRjaFNpemU6IG51bWJlcik6IFRbXVtdIHtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IFRbXVtdID0gW107XG5cbiAgICAgICAgbGV0IGJhdGNoOiBUW10gPSBbXTtcblxuICAgICAgICBpbnB1dC5mb3JFYWNoKGN1cnJlbnQgPT4ge1xuXG4gICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID09PSBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiYXRjaCk7XG4gICAgICAgICAgICAgICAgYmF0Y2ggPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmF0Y2gucHVzaChjdXJyZW50KTtcblxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYmF0Y2gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpa2UgZm9yRWFjaCBidXQgc2VxdWVudGlhbGx5IGV4ZWN1dGVzIGVhY2ggZnVuY3Rpb24uXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBhc3luY0ZvckVhY2g8VD4oaXRlbXM6IFRbXSwgY2FsbGJhY2s6IEFzeW5jQ2FsbGJhY2s8VD4pIHtcblxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaHVmZmxlIHRoZSBpbnB1dCBhcyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc2h1ZmZsZTxUPiguLi5pbnB1dDogVFtdKTogVFtdIHtcblxuICAgICAgICBjb25zdCBhcnIgPSBPYmplY3QuYXNzaWduKFtdLCBpbnB1dCk7XG5cbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFRzTGludFxuICAgICAgICBsZXQgaiwgeCwgaTtcbiAgICAgICAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgICAgIHggPSBhcnJbaV07XG4gICAgICAgICAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgICAgICAgICBhcnJbal0gPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB1cCB0byBgbGltaXRgIHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBpbnB1dC5cbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGhlYWQ8VD4oaW5wdXQ6IFJlYWRvbmx5QXJyYXk8VD4sIGxpbWl0OiBudW1iZXIpOiBUW10ge1xuXG4gICAgICAgIC8vIGFkanVzdCB0aGUgbGltaXQgc28gd2UgbmV2ZXIgZmV0Y2ggdG9vIG1hbnkgdmFsdWVzLlxuICAgICAgICBsaW1pdCA9IE1hdGgubWluKGxpbWl0LCBpbnB1dC5sZW5ndGgpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogVFtdID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgbGltaXQ7ICsraWR4KSB7XG4gICAgICAgICAgICByZXN1bHRbaWR4XSA9IGlucHV0W2lkeF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfVxuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXN5bmNDYWxsYmFjazxUPiB7XG4gICAgKGN1cnJlbnQ6IFQpOiBQcm9taXNlPHZvaWQ+O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSAncG9zaXRpb24nIG9iamVjdCBmb3IgY3JlYXRlU2libGluZ3MoKSB0aGF0IGhhcyBhIGN1cnJcbiAqIChjdXJyZW50KSwgcHJldiAocHJldmlvdXMpLCBhbmQgbmV4dCByZWZlcmVuY2VzIGZvciB3b3JraW5nIHdpdGggbGlzdHMgb2ZcbiAqIG9iamVjdHMuICBUaGUgcG9zaXRpb24gYWxsb3cgc3VzIHRvIGtub3cgd2hlcmUgd2UgY3VycmVudGx5IGFyZSBidXQgYWxzbyB0aGVcbiAqIHByZXZpb3VzIGFuZCBmdXR1cmUgc3RhdGVzLlxuICovXG5jbGFzcyBBcnJheVBvc2l0aW9uPFQ+IHtcblxuICAgIHB1YmxpYyByZWFkb25seSBwcmV2PzogVDtcblxuICAgIHB1YmxpYyByZWFkb25seSBjdXJyOiBUO1xuXG4gICAgcHVibGljIHJlYWRvbmx5IG5leHQ/OiBUO1xuXG4gICAgY29uc3RydWN0b3IocHJldjogVCB8IHVuZGVmaW5lZCwgY3VycjogVCwgbmV4dDogVCB8IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmN1cnIgPSBjdXJyO1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cblxufVxuIl19