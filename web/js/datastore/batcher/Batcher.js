"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = require("../../logger/Logger");
const log = Logger_1.Logger.create();
class Batcher {
    constructor(runnable) {
        this.tickets = [];
        this.runnable = runnable;
    }
    enqueue() {
        const ticket = new Ticket(this.runnable());
        this.tickets.push(ticket);
        if (this.tickets.length > 1) {
            const pending = this.tickets.length;
            return new PassiveBatch(pending, ticket);
        }
        return new ActiveBatch(this.tickets, this.runnable, ticket);
    }
}
exports.Batcher = Batcher;
class PassiveBatch {
    constructor(pending, ticket) {
        this.pending = pending;
        this.ticket = ticket;
    }
    run() {
        return Promise.resolve();
    }
}
exports.PassiveBatch = PassiveBatch;
class ActiveBatch {
    constructor(tickets, runnable, ticket) {
        this.batched = 0;
        this.batches = 0;
        this.ticketsPerBatch = [];
        this.tickets = tickets;
        this.runnable = runnable;
        this.ticket = ticket;
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this.tickets.length > 0) {
                yield this.iter();
            }
        });
    }
    iter() {
        return __awaiter(this, void 0, void 0, function* () {
            const nrTicketsToExecute = this.tickets.length;
            log.debug("Executing request for N tickets: ", nrTicketsToExecute);
            yield this.tickets[0].promise;
            const tickets = this.tickets.splice(0, nrTicketsToExecute);
            tickets.forEach(ticket => ticket.executed = true);
            this.ticketsPerBatch.push(nrTicketsToExecute);
            this.batched += nrTicketsToExecute;
            ++this.batches;
        });
    }
}
exports.ActiveBatch = ActiveBatch;
class Ticket {
    constructor(promise) {
        this.executed = false;
        this.promise = promise;
    }
}
exports.Ticket = Ticket;
function nullAsyncRunnable() {
    return __awaiter(this, void 0, void 0, function* () {
    });
}
exports.nullAsyncRunnable = nullAsyncRunnable;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmF0Y2hlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkJhdGNoZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQVFBLGdEQUEyQztBQUUzQyxNQUFNLEdBQUcsR0FBRyxlQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7QUFFNUIsTUFBYSxPQUFPO0lBTWhCLFlBQVksUUFBdUI7UUFGM0IsWUFBTyxHQUFhLEVBQUUsQ0FBQztRQUczQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztJQUM3QixDQUFDO0lBS00sT0FBTztRQUVWLE1BQU0sTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBRTNDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTFCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBcUJ6QixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztZQUVwQyxPQUFPLElBQUksWUFBWSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztTQUU1QztRQUVELE9BQU8sSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBRWhFLENBQUM7Q0FFSjtBQWxERCwwQkFrREM7QUFjRCxNQUFhLFlBQVk7SUFTckIsWUFBWSxPQUFlLEVBQUUsTUFBYztRQUN2QyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztJQUV6QixDQUFDO0lBRU0sR0FBRztRQUNOLE9BQU8sT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzdCLENBQUM7Q0FFSjtBQW5CRCxvQ0FtQkM7QUFLRCxNQUFhLFdBQVc7SUF1QnBCLFlBQVksT0FBaUIsRUFBRSxRQUF1QixFQUFFLE1BQWM7UUFsQi9ELFlBQU8sR0FBVyxDQUFDLENBQUM7UUFLcEIsWUFBTyxHQUFXLENBQUMsQ0FBQztRQUtwQixvQkFBZSxHQUFhLEVBQUUsQ0FBQztRQVNsQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztJQUN6QixDQUFDO0lBRVksR0FBRzs7WUFFWixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFJNUIsTUFBTSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7YUFFckI7UUFFTCxDQUFDO0tBQUE7SUFLWSxJQUFJOztZQUViLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7WUFDL0MsR0FBRyxDQUFDLEtBQUssQ0FBQyxtQ0FBbUMsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO1lBRW5FLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7WUFFOUIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLGtCQUFrQixDQUFDLENBQUM7WUFFM0QsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUM7WUFFbEQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsT0FBTyxJQUFJLGtCQUFrQixDQUFDO1lBRW5DLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUVuQixDQUFDO0tBQUE7Q0FFSjtBQTlERCxrQ0E4REM7QUFFRCxNQUFhLE1BQU07SUFVZixZQUFZLE9BQXNCO1FBSjNCLGFBQVEsR0FBWSxLQUFLLENBQUM7UUFLN0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFDM0IsQ0FBQztDQUVKO0FBZEQsd0JBY0M7QUFhRCxTQUFzQixpQkFBaUI7O0lBRXZDLENBQUM7Q0FBQTtBQUZELDhDQUVDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogVGhpcyBpcyB1c2VkIHRvIHByZXZlbnQgZHVwbGljYXRlIHdyaXRlcyBpbiBhIGNoYWluIGZyb20gdGhlIGV2ZW50IHN0b3JlIGFuZFxuICogb25seSB3cml0ZSB0aGUgZmlyc3QgYW5kIHRoZSBsYXN0LiBJdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gd3JpdGVcbiAqIGludGVybWVkaWF0ZSB3cml0ZXMgYmVjYXVzZSB3ZSdyZSBnb2luZyB0byBldmVudHVhbGx5IHdyaXRlIGhlIGxhc3QuXG4gKlxuICogaHR0cHM6Ly9tZWNoYW5pY2FsLXN5bXBhdGh5LmJsb2dzcG90LmNvbS8yMDExLzEwL3NtYXJ0LWJhdGNoaW5nLmh0bWxcbiAqL1xuaW1wb3J0IHtMb2dnZXJ9IGZyb20gJy4uLy4uL2xvZ2dlci9Mb2dnZXInO1xuXG5jb25zdCBsb2cgPSBMb2dnZXIuY3JlYXRlKCk7XG5cbmV4cG9ydCBjbGFzcyBCYXRjaGVyIHtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgcnVubmFibGU6IEFzeW5jUnVubmFibGU7XG5cbiAgICBwcml2YXRlIHRpY2tldHM6IFRpY2tldFtdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihydW5uYWJsZTogQXN5bmNSdW5uYWJsZSkge1xuICAgICAgICB0aGlzLnJ1bm5hYmxlID0gcnVubmFibGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5xdWV1ZSB0aGUgcnVubmFibGUgdG8gYmUgZXhlY3V0ZWQgYWdhaW4gYXMgcGFydCBvZiBhIGJhdGNoLlxuICAgICAqL1xuICAgIHB1YmxpYyBlbnF1ZXVlKCk6IEJhdGNoIHtcblxuICAgICAgICBjb25zdCB0aWNrZXQgPSBuZXcgVGlja2V0KHRoaXMucnVubmFibGUoKSk7XG5cbiAgICAgICAgdGhpcy50aWNrZXRzLnB1c2godGlja2V0KTtcblxuICAgICAgICBpZiAodGhpcy50aWNrZXRzLmxlbmd0aCA+IDEpIHtcblxuICAgICAgICAgICAgLy8gUHVzaCBhIHRpY2tldCBvbiBzbyB0aGF0IHRoZSB3b3JrZXIgdGhyZWFkIGhhbmRsaW5nIHRoaXMgSU9cbiAgICAgICAgICAgIC8vIGNhbiBjb21wbGV0ZSBteSB3b3JrIGZvciBtZSB3aGVuIGl0IGZpbmlzaGVzIHRoZSBuZXh0IHdyaXRlLlxuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIGNvdW50IG9mIHRpY2tldHMgaXMgdW5ib3VuZGVkIGFuZCBpZiB0aGlzIHN5c3RlbVxuICAgICAgICAgICAgLy8gZ29lcyB0b28gZmFzdCB3ZSBtaWdodCB1c2UgZXhjZXNzaXZlIG1lbW9yeS4gIEknbSBub3Qgc3VyZSBpZlxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSB3YXkgdG8gZ2V0IGFyb3VuZCB0aGlzIGluIEphdmFzY3JpcHQgYXMgSSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBsb2NrIGFyb3VuZCBhIHZhcmlhYmxlIGFuZCBJIGRvbid0IHRoaW5rIEkgY2FuIGRvIHRoYXQuXG5cbiAgICAgICAgICAgIC8vIE5PVEU6IHRoZSBleGNlc3MgZW50cnkgaXNuJ3QgZ29pbmcgdG8gY2hhbmdlIGFueXRoaW5nLi4gaXQncyBqdXN0XG4gICAgICAgICAgICAvLyBnb2luZyB0byBtZWFuIHRoYXQgd2UgZG9uJ3Qga25vdyBob3cgbWFueSB3ZSBkZWxldGVkL2luamVjdGVkLlxuXG4gICAgICAgICAgICAvLyBOT1RFOiB0aGVyZSdzIGFub3RoZXIgc3RyYXRlZ3kgdGhhdCB3ZSBjb3VsZCBwdXJzdWUuIFdlIGNvdWxkXG4gICAgICAgICAgICAvLyBzdGljayBPTkUgZW50cnkgaW50byB0aGUgcXVldWUgYW5kIHRoZW4gdGhhdCB3b3VsZCBiZSBhbiBvYmplY3RcbiAgICAgICAgICAgIC8vIHdpdGggYSBjb3VudCBvZiB0aGUgcGVuZGluZyAvYmF0Y2hlZCBpdGVtcy4gIFRoZSBvbmx5IGlzc3VlIHRoZXJlXG4gICAgICAgICAgICAvLyBpcyB0aGF0IHRoZSBhY2NvdW50aW5nIGNvdWxkIGJlIGluYWNjdXJhdGUgYXMgd2UgaGF2ZSBhIHJhY2VcbiAgICAgICAgICAgIC8vIGJldHdlZW4gdGhlIHJlYWRlciBhbmQgYSB3cml0ZXIuICBJbiBwcmFjdGljZSBJIGRvbid0IHRoaW5rIHRoaXNcbiAgICAgICAgICAgIC8vIHdvdWxkIHJ1biBvdXQgb2YgbWVtb3J5IHNvIHRoaXMgaXMgcHJvYmFibHkgYW4gYWNjZXB0YWJsZVxuICAgICAgICAgICAgLy8gc3RyYXRlZ3kuXG5cbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLnRpY2tldHMubGVuZ3RoO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhc3NpdmVCYXRjaChwZW5kaW5nLCB0aWNrZXQpO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZUJhdGNoKHRoaXMudGlja2V0cywgdGhpcy5ydW5uYWJsZSwgdGlja2V0KTtcblxuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoIHtcblxuICAgIHJlYWRvbmx5IHRpY2tldDogVGlja2V0O1xuXG4gICAgcnVuKCk6IFByb21pc2U8dm9pZD47XG5cbn1cblxuLyoqXG4gKiBNZXRhZGF0YSBhcm91bmQgdGhlIGEgZGVsYXllZCBleGVjdXRpb24uICBJRSBubyB3b3JrIHdhcyBjb21wbGV0ZWQgYnV0XG4gKiBpbnN0ZWFkIHNjaGVkdWxlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhc3NpdmVCYXRjaCBpbXBsZW1lbnRzIEJhdGNoIHtcblxuICAgIHB1YmxpYyByZWFkb25seSB0aWNrZXQ6IFRpY2tldDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgdGlja2V0cyBpbiB0aGUgcXVldWUgYXQgdGhlIHRpbWUgdGhpcyB3YXMgZXhlY3V0ZWQuXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IHBlbmRpbmc6IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKHBlbmRpbmc6IG51bWJlciwgdGlja2V0OiBUaWNrZXQpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gcGVuZGluZztcbiAgICAgICAgdGhpcy50aWNrZXQgPSB0aWNrZXQ7XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgcnVuKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG59XG5cbi8qKlxuICogTWV0ZGF0YSBhcm91bmQgdGhlIGxhc3QgZXhlY3V0aW9uIG9mIHRoaXMgYmF0Y2guIE1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFjdGl2ZUJhdGNoIGltcGxlbWVudHMgQmF0Y2ggIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgYmF0Y2hlZCByZWNvcmRzIHdyaXR0ZW4gYWNyb3NzIGFsbCBiYXRjaGVzLlxuICAgICAqL1xuICAgIHB1YmxpYyBiYXRjaGVkOiBudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIG51bWJlciBvZiBiYXRjaGVzIGV4ZWN1dGVkIGluIHRoZSBsYXN0IGNhbGwgdG8gZXhlY3V0ZSgpXG4gICAgICovXG4gICAgcHVibGljIGJhdGNoZXM6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBGb3IgZWFjaCBiYXRjaCwgdGhlIG51bWJlciBvZiB0aWNrZXRzIGV4ZWN1dGVkIHdpdGhpbiB0aGF0IGJhdGNoLlxuICAgICAqL1xuICAgIHB1YmxpYyB0aWNrZXRzUGVyQmF0Y2g6IG51bWJlcltdID0gW107XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IHRpY2tldHM6IFRpY2tldFtdO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBydW5uYWJsZTogQXN5bmNSdW5uYWJsZTtcblxuICAgIHB1YmxpYyByZWFkb25seSB0aWNrZXQ6IFRpY2tldDtcblxuICAgIGNvbnN0cnVjdG9yKHRpY2tldHM6IFRpY2tldFtdLCBydW5uYWJsZTogQXN5bmNSdW5uYWJsZSwgdGlja2V0OiBUaWNrZXQpIHtcbiAgICAgICAgdGhpcy50aWNrZXRzID0gdGlja2V0cztcbiAgICAgICAgdGhpcy5ydW5uYWJsZSA9IHJ1bm5hYmxlO1xuICAgICAgICB0aGlzLnRpY2tldCA9IHRpY2tldDtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgcnVuKCk6IFByb21pc2U8dm9pZD4ge1xuXG4gICAgICAgIHdoaWxlICh0aGlzLnRpY2tldHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8ga2VlcCB3cml0aW5nIHdoaWxlIHdlIGhhdmUgdGlja2V0cy4gVGhlIG90aGVyIHRpY2tldHMgYXJlIHdoZW5cbiAgICAgICAgICAgIC8vIHBlb3BsZSBoYXZlIGJlZW4gd3JpdGluZyB3aGlsZSB3ZSB3ZXJlIGJsb2NrZWQuXG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaXRlcigpO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IG9uY2UgYmF0Y2ggaXRlcmF0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBpdGVyKCkge1xuXG4gICAgICAgIGNvbnN0IG5yVGlja2V0c1RvRXhlY3V0ZSA9IHRoaXMudGlja2V0cy5sZW5ndGg7XG4gICAgICAgIGxvZy5kZWJ1ZyhcIkV4ZWN1dGluZyByZXF1ZXN0IGZvciBOIHRpY2tldHM6IFwiLCBuclRpY2tldHNUb0V4ZWN1dGUpO1xuXG4gICAgICAgIGF3YWl0IHRoaXMudGlja2V0c1swXS5wcm9taXNlO1xuXG4gICAgICAgIGNvbnN0IHRpY2tldHMgPSB0aGlzLnRpY2tldHMuc3BsaWNlKDAsIG5yVGlja2V0c1RvRXhlY3V0ZSk7XG5cbiAgICAgICAgdGlja2V0cy5mb3JFYWNoKHRpY2tldCA9PiB0aWNrZXQuZXhlY3V0ZWQgPSB0cnVlKTtcblxuICAgICAgICB0aGlzLnRpY2tldHNQZXJCYXRjaC5wdXNoKG5yVGlja2V0c1RvRXhlY3V0ZSk7XG4gICAgICAgIHRoaXMuYmF0Y2hlZCArPSBuclRpY2tldHNUb0V4ZWN1dGU7XG5cbiAgICAgICAgKyt0aGlzLmJhdGNoZXM7XG5cbiAgICB9XG5cbn1cblxuZXhwb3J0IGNsYXNzIFRpY2tldCB7XG5cblxuICAgIC8qKlxuICAgICAqIFRydWUgd2hlbiB0aGUgcnVubmFibGUgd2FzIGV4ZWN1dGVkIGFzIHJlcXVlc3RlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZXhlY3V0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHB1YmxpYyByZWFkb25seSBwcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xuXG4gICAgY29uc3RydWN0b3IocHJvbWlzZTogUHJvbWlzZTx2b2lkPikge1xuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIH1cblxufVxuXG4vKipcbiAqIEludGVyZmFjZSB0aGF0IGp1c3QgcmV0dXJucyBhIHByb21pc2UgYW5kIHBlcmZvcm1zIHdvcmsuIFRoZSByZXN1bHRzIGFyZSBub3RcbiAqIG5lZWRlZCBvdGhlciB0aGFuIHRvIG1ha2Ugc3VyZSB3ZSBleGVjdXRlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFzeW5jUnVubmFibGUge1xuICAgICgpOiBQcm9taXNlPHZvaWQ+O1xufVxuXG4vKipcbiAqIEFzeW5jIHJ1bm5hYmxlIHRoYXQgcGVyZm9ybXMgbm8gb3BlcmF0aW9uLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbnVsbEFzeW5jUnVubmFibGUoKSB7XG5cbn1cbiJdfQ==