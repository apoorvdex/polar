"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const IPCMessage_1 = require("./IPCMessage");
const Objects_1 = require("../../util/Objects");
const IPCError_1 = require("./IPCError");
const assert = require('assert');
describe('IPCMessage', function () {
    class Name {
        constructor(first, last) {
            this.first = first;
            this.last = last;
        }
        static create(obj) {
            return Objects_1.Objects.createInstance(Name.prototype, obj);
        }
    }
    let name = new Name("Alice", "Smith");
    let ipcMessage = new IPCMessage_1.IPCMessage('name', name);
    it("Test constructor function to re-create object properly", function () {
        assert.equal(name instanceof Name, true);
        let obj = Object.assign({}, ipcMessage);
        console.log("Trying to create IPC message from basic object: ", obj);
        ipcMessage = IPCMessage_1.IPCMessage.create(obj, Name.create);
        name = ipcMessage.value;
        assert.equal(name instanceof Name, true);
        assert.equal(name.first, "Alice");
        assert.equal(name.last, "Smith");
    });
    it("Test constructor function without constructor", function () {
        let obj = Object.assign({}, ipcMessage);
        console.log("Trying to create IPC message from basic object: ", obj);
        ipcMessage = IPCMessage_1.IPCMessage.create(obj);
        name = ipcMessage.value;
        assert.equal(name instanceof Name, true);
        assert.equal(name.first, "Alice");
        assert.equal(name.last, "Smith");
    });
    it("Create an IPC message from an error IPC message", function () {
        let errMessage = IPCMessage_1.IPCMessage.createError('fake', IPCError_1.IPCError.create(new Error("Fake error")));
        errMessage = IPCMessage_1.IPCMessage.create(errMessage);
        assert.throws(() => {
            errMessage.value();
        });
        assert.throws(() => {
            errMessage.value;
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSVBDTWVzc2FnZVRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJJUENNZXNzYWdlVGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDZDQUF3QztBQUN4QyxnREFBMkM7QUFDM0MseUNBQW9DO0FBRXBDLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUVqQyxRQUFRLENBQUMsWUFBWSxFQUFFO0lBRW5CLE1BQU0sSUFBSTtRQUtOLFlBQVksS0FBYSxFQUFFLElBQVk7WUFDbkMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7WUFDbkIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDckIsQ0FBQztRQUVNLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBUTtZQUN6QixPQUFPLGlCQUFPLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDdkQsQ0FBQztLQUVKO0lBRUQsSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3RDLElBQUksVUFBVSxHQUFHLElBQUksdUJBQVUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFHOUMsRUFBRSxDQUFDLHdEQUF3RCxFQUFFO1FBRXpELE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxZQUFZLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUV6QyxJQUFJLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUV4QyxPQUFPLENBQUMsR0FBRyxDQUFDLGtEQUFrRCxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBRXJFLFVBQVUsR0FBRyx1QkFBVSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRWpELElBQUksR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDO1FBRXhCLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxZQUFZLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN6QyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDbEMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRXJDLENBQUMsQ0FBQyxDQUFDO0lBRUgsRUFBRSxDQUFDLCtDQUErQyxFQUFFO1FBRWhELElBQUksR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBRXhDLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0RBQWtELEVBQUUsR0FBRyxDQUFDLENBQUM7UUFFckUsVUFBVSxHQUFHLHVCQUFVLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXBDLElBQUksR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDO1FBRXhCLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxZQUFZLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN6QyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDbEMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRXJDLENBQUMsQ0FBQyxDQUFDO0lBR0gsRUFBRSxDQUFDLGlEQUFpRCxFQUFFO1FBRWxELElBQUksVUFBVSxHQUNWLHVCQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxtQkFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFN0UsVUFBVSxHQUFHLHVCQUFVLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTNDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFO1lBQ2YsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3ZCLENBQUMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUU7WUFDZixVQUFVLENBQUMsS0FBSyxDQUFDO1FBQ3JCLENBQUMsQ0FBQyxDQUFDO0lBRVAsQ0FBQyxDQUFDLENBQUM7QUFHUCxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SVBDTWVzc2FnZX0gZnJvbSAnLi9JUENNZXNzYWdlJztcbmltcG9ydCB7T2JqZWN0c30gZnJvbSAnLi4vLi4vdXRpbC9PYmplY3RzJztcbmltcG9ydCB7SVBDRXJyb3J9IGZyb20gJy4vSVBDRXJyb3InO1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuZGVzY3JpYmUoJ0lQQ01lc3NhZ2UnLCBmdW5jdGlvbigpIHtcblxuICAgIGNsYXNzIE5hbWUge1xuXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBmaXJzdDogc3RyaW5nO1xuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgbGFzdDogc3RyaW5nO1xuXG4gICAgICAgIGNvbnN0cnVjdG9yKGZpcnN0OiBzdHJpbmcsIGxhc3Q6IHN0cmluZykge1xuICAgICAgICAgICAgdGhpcy5maXJzdCA9IGZpcnN0O1xuICAgICAgICAgICAgdGhpcy5sYXN0ID0gbGFzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlKG9iajogYW55KTogTmFtZSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0cy5jcmVhdGVJbnN0YW5jZShOYW1lLnByb3RvdHlwZSwgb2JqKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgbGV0IG5hbWUgPSBuZXcgTmFtZShcIkFsaWNlXCIsIFwiU21pdGhcIik7XG4gICAgbGV0IGlwY01lc3NhZ2UgPSBuZXcgSVBDTWVzc2FnZSgnbmFtZScsIG5hbWUpO1xuXG5cbiAgICBpdChcIlRlc3QgY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gcmUtY3JlYXRlIG9iamVjdCBwcm9wZXJseVwiLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgYXNzZXJ0LmVxdWFsKG5hbWUgaW5zdGFuY2VvZiBOYW1lLCB0cnVlKTtcblxuICAgICAgICBsZXQgb2JqID0gT2JqZWN0LmFzc2lnbih7fSwgaXBjTWVzc2FnZSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJUcnlpbmcgdG8gY3JlYXRlIElQQyBtZXNzYWdlIGZyb20gYmFzaWMgb2JqZWN0OiBcIiwgb2JqKTtcblxuICAgICAgICBpcGNNZXNzYWdlID0gSVBDTWVzc2FnZS5jcmVhdGUob2JqLCBOYW1lLmNyZWF0ZSk7XG5cbiAgICAgICAgbmFtZSA9IGlwY01lc3NhZ2UudmFsdWU7XG5cbiAgICAgICAgYXNzZXJ0LmVxdWFsKG5hbWUgaW5zdGFuY2VvZiBOYW1lLCB0cnVlKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKG5hbWUuZmlyc3QsIFwiQWxpY2VcIik7XG4gICAgICAgIGFzc2VydC5lcXVhbChuYW1lLmxhc3QsIFwiU21pdGhcIik7XG5cbiAgICB9KTtcblxuICAgIGl0KFwiVGVzdCBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3aXRob3V0IGNvbnN0cnVjdG9yXCIsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBsZXQgb2JqID0gT2JqZWN0LmFzc2lnbih7fSwgaXBjTWVzc2FnZSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJUcnlpbmcgdG8gY3JlYXRlIElQQyBtZXNzYWdlIGZyb20gYmFzaWMgb2JqZWN0OiBcIiwgb2JqKTtcblxuICAgICAgICBpcGNNZXNzYWdlID0gSVBDTWVzc2FnZS5jcmVhdGUob2JqKTtcblxuICAgICAgICBuYW1lID0gaXBjTWVzc2FnZS52YWx1ZTtcblxuICAgICAgICBhc3NlcnQuZXF1YWwobmFtZSBpbnN0YW5jZW9mIE5hbWUsIHRydWUpO1xuICAgICAgICBhc3NlcnQuZXF1YWwobmFtZS5maXJzdCwgXCJBbGljZVwiKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKG5hbWUubGFzdCwgXCJTbWl0aFwiKTtcblxuICAgIH0pO1xuXG5cbiAgICBpdChcIkNyZWF0ZSBhbiBJUEMgbWVzc2FnZSBmcm9tIGFuIGVycm9yIElQQyBtZXNzYWdlXCIsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGxldCBlcnJNZXNzYWdlOiBJUENNZXNzYWdlPGFueT4gPVxuICAgICAgICAgICAgSVBDTWVzc2FnZS5jcmVhdGVFcnJvcignZmFrZScsIElQQ0Vycm9yLmNyZWF0ZShuZXcgRXJyb3IoXCJGYWtlIGVycm9yXCIpKSk7XG5cbiAgICAgICAgZXJyTWVzc2FnZSA9IElQQ01lc3NhZ2UuY3JlYXRlKGVyck1lc3NhZ2UpO1xuXG4gICAgICAgIGFzc2VydC50aHJvd3MoKCkgPT4ge1xuICAgICAgICAgICAgZXJyTWVzc2FnZS52YWx1ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBhc3NlcnQudGhyb3dzKCgpID0+IHtcbiAgICAgICAgICAgIGVyck1lc3NhZ2UudmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cblxufSk7XG4iXX0=